#Given a starting array of integers, return all permutations of the array
#A permutation is all possiblities of positions for each number in nums to take
#We can start with a bottom up recursion approach, starting at the final value of list, and inserting
#Values at each possible position until the list nums is rebuilt
#We have n decisions per each insertion, as we can add a number in each spot

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        
        res = []
        def backtrack(i):
            #To start permutations, start at the final element of list
            #And add each possible insertion
            if i >= len(nums):
                return [[]] #Start with an empty list of permutations
            
            #Take previous permutations generated by previous call / base case
            perms = backtrack(i+1)
            newPerms = [] #Generate new permutations
            #For each of the previous permutations
            for j in range(len(perms)):
                #Insert the ith value into every possible insertion point
                #In the permutation within a copy, add the copy to the list of new permutations
                for k in range(len(perms[j]) +1):
                    pcopy = perms[j].copy()
                    pcopy.insert(k, nums[i])
                    newPerms.append(pcopy[:])
            print(newPerms, nums[i])
            return newPerms
        return backtrack(0)
        
